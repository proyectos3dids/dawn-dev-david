{% comment %}
  Renders checkout button hijacker.
  This snippet intercepts ONLY checkout button clicks (not Add to Cart buttons) and prevents default behavior,
  then disables the button using the newButtonAction function.
  
  Targets:
  - Cart drawer checkout button
  - Main cart footer checkout button  
  - Cart notification checkout button
  
  Usage:
  {% render 'checkout-hijacker' %}
{% endcomment %}

{% comment %} Check if customer is logged in and has "re" tag {% endcomment %}
{% assign recargo = false %}
NO
{{ customer.name }}
{% if customer %}
  SI
  {% for tag in customer.tags %}
    {% assign tag_lowercase = tag | downcase %}
    {{ tag_lowercase }}
    {% if tag_lowercase == 're' %}
      {% assign recargo = true %}
      {% break %}
    {% endif %}
  {% endfor %}
{% endif %}

{{ recargo }}

{% comment %} Hidden field for cart attribute {% endcomment %}
<input type="hidden" id="cart-re-attribute" {% if recargo %}data-re="true"{% endif %} style="display: none;">

<script>
  // Import PUB_SUB_EVENTS and pubsub functions
  const PUB_SUB_EVENTS = {
    cartUpdate: 'cart-update',
    quantityUpdate: 'quantity-update',
    optionValueSelectionChange: 'option-value-selection-change',
    variantChange: 'variant-change',
    cartError: 'cart-error',
  };

  let subscribers = {};

  function subscribe(eventName, callback) {
    if (subscribers[eventName] === undefined) {
      subscribers[eventName] = [];
    }

    subscribers[eventName] = [...subscribers[eventName], callback];

    return function unsubscribe() {
      subscribers[eventName] = subscribers[eventName].filter((cb) => {
        return cb !== callback;
      });
    };
  }

  function publish(eventName, data) {
    if (subscribers[eventName]) {
      const promises = subscribers[eventName]
        .map((callback) => callback(data))
      return Promise.all(promises);
    } else {
      return Promise.resolve()
    }
  }

  class CheckoutHijacker {
    constructor() {
      this.init();
    }

    init() {
      // Wait for DOM to be ready
      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', () => this.hijackButtons());
      } else {
        this.hijackButtons();
      }
    }

    hijackButtons() {
      // Hijack checkout buttons in cart drawer
      this.hijackCartDrawerCheckout();
      
      // Hijack checkout buttons in main cart footer
      this.hijackMainCartCheckout();
      
      // Hijack cart notification checkout
      this.hijackCartNotificationCheckout();
    }



    hijackCartDrawerCheckout() {
      const cartDrawerCheckout = document.querySelector('#CartDrawer-Checkout');
      
      if (cartDrawerCheckout) {
        // Clone to remove existing listeners
        const newButton = cartDrawerCheckout.cloneNode(true);
        cartDrawerCheckout.parentNode.replaceChild(newButton, cartDrawerCheckout);
        
        newButton.addEventListener('click', (evt) => {
          evt.preventDefault();
          evt.stopPropagation();
          this.newButtonAction(newButton);
        });
      }
    }

    hijackMainCartCheckout() {
      const mainCartCheckout = document.querySelector('#checkout');
      
      if (mainCartCheckout) {
        // Clone to remove existing listeners
        const newButton = mainCartCheckout.cloneNode(true);
        mainCartCheckout.parentNode.replaceChild(newButton, mainCartCheckout);
        
        newButton.addEventListener('click', (evt) => {
          evt.preventDefault();
          evt.stopPropagation();
          this.newButtonAction(newButton);
        });
      }
    }

    hijackCartNotificationCheckout() {
      const cartNotificationForm = document.querySelector('#cart-notification-form');
      
      if (cartNotificationForm) {
        const checkoutButton = cartNotificationForm.querySelector('button[name="checkout"]');
        
        if (checkoutButton) {
          // Clone to remove existing listeners
          const newButton = checkoutButton.cloneNode(true);
          checkoutButton.parentNode.replaceChild(newButton, checkoutButton);
          
          newButton.addEventListener('click', (evt) => {
            evt.preventDefault();
            evt.stopPropagation();
            this.newButtonAction(newButton);
          });
        }
        
        // Also hijack form submit
        const newForm = cartNotificationForm.cloneNode(true);
        cartNotificationForm.parentNode.replaceChild(newForm, cartNotificationForm);
        
        newForm.addEventListener('submit', (evt) => {
          evt.preventDefault();
          evt.stopPropagation();
          const button = newForm.querySelector('button[name="checkout"]');
          this.newButtonAction(button);
        });
      }
    }

    // Function to get variant ID from theme settings
    getRecargoEquivalenciaVariant() {
      // Get the product from theme settings
      const productHandle = '{{ settings.recargo_equivalencia_product.handle }}';
      const variantId = '{{ settings.recargo_equivalencia_product.selected_or_first_available_variant.id }}';
      
      if (productHandle && variantId && variantId !== '') {
        return parseInt(variantId);
      }
      
      console.error('Recargo de equivalencia product not configured in theme settings');
      return null;
    }

    // Function to add product to cart
     addProductToCart(variantId, messageElement, onSuccess, onError) {
       const formData = {
         'items': [{
           'id': variantId,
           'quantity': 1
         }]
       };

       fetch('/cart/add.js', {
         method: 'POST',
         headers: {
           'Content-Type': 'application/json',
         },
         body: JSON.stringify(formData)
       })
       .then(response => {
         if (!response.ok) {
           throw new Error(`HTTP error! status: ${response.status}`);
         }
         return response.json();
       })
       .then(data => {
         console.log('Product added successfully:', data);
         
         // Check if the response indicates an error
         if (data.status && data.status === 422) {
           throw new Error(data.description || 'Error al añadir producto al carrito');
         }
         
         messageElement.textContent = 'Producto añadido exitosamente!';
         messageElement.style.backgroundColor = '#d4edda';
         messageElement.style.color = '#155724';
         
         // Dispatch cart update event to refresh cart UI
         publish(PUB_SUB_EVENTS.cartUpdate, {
           source: 'checkout-hijacker',
           cartData: data,
           variantId: variantId
         });
         
         // Also directly call onCartUpdate for immediate refresh
         const cartItems = document.querySelector('cart-items');
         if (cartItems && typeof cartItems.onCartUpdate === 'function') {
           cartItems.onCartUpdate();
         }
         
         const cartDrawerItems = document.querySelector('cart-drawer-items');
         if (cartDrawerItems && typeof cartDrawerItems.onCartUpdate === 'function') {
           cartDrawerItems.onCartUpdate();
         }
         
         // Update the hidden input to reflect the new cart state
         const productCheckInput = document.getElementById('cart-product-check');
         if (productCheckInput) {
           productCheckInput.setAttribute('data-product-in-cart', 'true');
         }
         
         // Call success callback
         if (onSuccess) {
           onSuccess();
         }
       })
       .catch((error) => {
         console.error('Error adding product to cart:', error);
         
         let errorMessage = 'Error al añadir producto al carrito.';
         if (error.message && error.message !== 'Failed to fetch') {
           errorMessage = error.message;
         }
         
         // Call error callback
         if (onError) {
           onError(errorMessage);
         } else {
           messageElement.textContent = errorMessage;
           messageElement.style.backgroundColor = '#f8d7da';
           messageElement.style.color = '#721c24';
         }
       });
     }

    // Function that handles the new button action
    newButtonAction(button) {
      if (!button) return;
      
      // Disable button to prevent multiple clicks
      button.disabled = true;
      button.setAttribute('disabled', 'disabled');
      button.setAttribute('aria-disabled', 'true');
      button.classList.add('disabled');
      button.style.opacity = '0.6';
      button.style.cursor = 'not-allowed';
      
      // Check the hidden input for re attribute
      const reInput = document.getElementById('cart-re-attribute');
      const hasReAttribute = reInput && reInput.hasAttribute('data-re') && reInput.getAttribute('data-re') === 'true';
      
      // Get original button text and create spinner
      const buttonText = button.querySelector('span') || button;
      const originalText = buttonText.textContent;
      
      // Create spinner element
      const spinner = document.createElement('span');
      spinner.innerHTML = '⏳ ';
      spinner.className = 'checkout-spinner';
      
      buttonText.textContent = 'Procesando...';
      buttonText.insertBefore(spinner, buttonText.firstChild);
      
      // Log for debugging
      console.log('Checkout button hijacked:', button);
      
      // Remove any existing message
      const existingMessage = button.parentNode.querySelector('.checkout-hijacker-message');
      if (existingMessage) {
        existingMessage.remove();
      }

      // Create message element
      const messageElement = document.createElement('div');
      messageElement.className = 'checkout-hijacker-message';
      messageElement.style.cssText = 'margin-top: 10px; padding: 10px; background-color: #f0f0f0; border-radius: 4px; font-size: 14px; text-align: center;';
      
      // Function to restore button state
      const restoreButton = () => {
        button.disabled = false;
        button.removeAttribute('disabled');
        button.setAttribute('aria-disabled', 'false');
        button.classList.remove('disabled');
        button.style.opacity = '1';
        button.style.cursor = 'pointer';
        buttonText.textContent = originalText;
        if (spinner.parentNode) {
          spinner.remove();
        }
      };
      
      // Function to proceed to checkout
      const proceedToCheckout = () => {
        messageElement.textContent = 'Redirigiendo al checkout...';
        messageElement.style.backgroundColor = '#d4edda';
        messageElement.style.color = '#155724';
        
        setTimeout(() => {
          window.location.href = '/checkout';
        }, 1000);
      };
      
      // Function to show error and allow retry
      const showError = (errorMessage) => {
        restoreButton();
        messageElement.textContent = errorMessage + ' Haz clic en "Finalizar pedido" para intentar de nuevo.';
        messageElement.style.backgroundColor = '#f8d7da';
        messageElement.style.color = '#721c24';
      };
      
      // Check if customer has 're' tag and show appropriate message
      if (hasReAttribute) {
        // Check if product is already in cart using the hidden input
        const productCheckInput = document.getElementById('cart-product-check');
        const productInCart = productCheckInput && productCheckInput.getAttribute('data-product-in-cart') === 'true';
        
        if (productInCart) {
          messageElement.textContent = 'Producto ya está en el carrito. Procediendo al checkout...';
          messageElement.style.backgroundColor = '#d4edda';
          messageElement.style.color = '#155724';
          
          // Proceed to checkout since product is already in cart
          proceedToCheckout();
        } else {
          messageElement.textContent = 'Añadiendo producto al carrito...';
          messageElement.style.backgroundColor = '#d1ecf1';
          messageElement.style.color = '#0c5460';
          
          // Get product from theme settings
          const variantId = this.getRecargoEquivalenciaVariant();
          if (variantId) {
            this.addProductToCart(variantId, messageElement, proceedToCheckout, showError);
          } else {
            showError('Error: Producto de recargo no configurado en las configuraciones del tema.');
          }
        }
      } else {
        // For users without 're' tag, proceed directly to checkout
        proceedToCheckout();
      }

      // Insert message after the button
      button.parentNode.insertBefore(messageElement, button.nextSibling);
    }
  }

  // Initialize the hijacker
  new CheckoutHijacker();
</script>

<style>
  /* Optional: Style for disabled hijacked buttons */
  button.disabled {
    opacity: 0.6;
    cursor: not-allowed;
  }
</style>