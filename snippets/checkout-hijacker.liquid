{% comment %}
  Renders checkout button hijacker.
  This snippet intercepts ONLY checkout button clicks (not Add to Cart buttons) and prevents default behavior,
  then disables the button using the newButtonAction function.
  
  Targets:
  - Cart drawer checkout button
  - Main cart footer checkout button  
  - Cart notification checkout button
  
  Usage:
  {% render 'checkout-hijacker' %}
{% endcomment %}

{% comment %} Check if customer is logged in and has "re" tag {% endcomment %}
{% assign recargo = false %}
NO
{{ customer.name }}
{% if customer %}
  SI
  {% for tag in customer.tags %}
    {% assign tag_lowercase = tag | downcase %}
    {{ tag_lowercase }}
    {% if tag_lowercase == 're' %}
      {% assign recargo = true %}
      {% break %}
    {% endif %}
  {% endfor %}
{% endif %}

{{ recargo }}

{% comment %} Hidden field for cart attribute {% endcomment %}
<input type="hidden" id="cart-re-attribute" {% if recargo %}data-re="true"{% endif %} style="display: none;">

<script>
  // Import PUB_SUB_EVENTS and pubsub functions
  const PUB_SUB_EVENTS = {
    cartUpdate: 'cart-update',
    quantityUpdate: 'quantity-update',
    optionValueSelectionChange: 'option-value-selection-change',
    variantChange: 'variant-change',
    cartError: 'cart-error',
  };

  let subscribers = {};

  function subscribe(eventName, callback) {
    if (subscribers[eventName] === undefined) {
      subscribers[eventName] = [];
    }

    subscribers[eventName] = [...subscribers[eventName], callback];

    return function unsubscribe() {
      subscribers[eventName] = subscribers[eventName].filter((cb) => {
        return cb !== callback;
      });
    };
  }

  function publish(eventName, data) {
    if (subscribers[eventName]) {
      const promises = subscribers[eventName]
        .map((callback) => callback(data))
      return Promise.all(promises);
    } else {
      return Promise.resolve()
    }
  }

  class CheckoutHijacker {
    constructor() {
      this.init();
    }

    init() {
      // Wait for DOM to be ready
      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', () => this.hijackButtons());
      } else {
        this.hijackButtons();
      }
    }

    hijackButtons() {
      // Hijack checkout buttons in cart drawer
      this.hijackCartDrawerCheckout();
      
      // Hijack checkout buttons in main cart footer
      this.hijackMainCartCheckout();
      
      // Hijack cart notification checkout
      this.hijackCartNotificationCheckout();
    }



    hijackCartDrawerCheckout() {
      const cartDrawerCheckout = document.querySelector('#CartDrawer-Checkout');
      
      if (cartDrawerCheckout) {
        // Clone to remove existing listeners
        const newButton = cartDrawerCheckout.cloneNode(true);
        cartDrawerCheckout.parentNode.replaceChild(newButton, cartDrawerCheckout);
        
        newButton.addEventListener('click', (evt) => {
          evt.preventDefault();
          evt.stopPropagation();
          this.newButtonAction(newButton);
        });
      }
    }

    hijackMainCartCheckout() {
      const mainCartCheckout = document.querySelector('#checkout');
      
      if (mainCartCheckout) {
        // Clone to remove existing listeners
        const newButton = mainCartCheckout.cloneNode(true);
        mainCartCheckout.parentNode.replaceChild(newButton, mainCartCheckout);
        
        newButton.addEventListener('click', (evt) => {
          evt.preventDefault();
          evt.stopPropagation();
          this.newButtonAction(newButton);
        });
      }
    }

    hijackCartNotificationCheckout() {
      const cartNotificationForm = document.querySelector('#cart-notification-form');
      
      if (cartNotificationForm) {
        const checkoutButton = cartNotificationForm.querySelector('button[name="checkout"]');
        
        if (checkoutButton) {
          // Clone to remove existing listeners
          const newButton = checkoutButton.cloneNode(true);
          checkoutButton.parentNode.replaceChild(newButton, checkoutButton);
          
          newButton.addEventListener('click', (evt) => {
            evt.preventDefault();
            evt.stopPropagation();
            this.newButtonAction(newButton);
          });
        }
        
        // Also hijack form submit
        const newForm = cartNotificationForm.cloneNode(true);
        cartNotificationForm.parentNode.replaceChild(newForm, cartNotificationForm);
        
        newForm.addEventListener('submit', (evt) => {
          evt.preventDefault();
          evt.stopPropagation();
          const button = newForm.querySelector('button[name="checkout"]');
          this.newButtonAction(button);
        });
      }
    }

    // Function to get variant ID from theme settings
    getRecargoEquivalenciaVariant() {
      // Get the product from theme settings
      const productHandle = '{{ settings.recargo_equivalencia_product.handle }}';
      const variantId = '{{ settings.recargo_equivalencia_product.selected_or_first_available_variant.id }}';
      
      if (productHandle && variantId && variantId !== '') {
        return parseInt(variantId);
      }
      
      console.error('Recargo de equivalencia product not configured in theme settings');
      return null;
    }

    // Function to check and fix recargo equivalencia quantity in cart
    checkAndFixRecargoQuantity(variantId, callback) {
      // Get current cart
      fetch('/cart.js')
        .then(response => response.json())
        .then(cart => {
          // Find the recargo equivalencia product in cart
          const recargoItem = cart.items.find(item => item.variant_id === variantId);
          
          if (recargoItem && recargoItem.quantity > 1) {
            // Update quantity to 1
            const updateData = {
              'id': variantId,
              'quantity': 1
            };
            
            fetch('/cart/change.js', {
              method: 'POST',
              headers: {
                'Content-Type': 'application/json',
              },
              body: JSON.stringify(updateData)
            })
            .then(response => response.json())
            .then(data => {
              console.log('Recargo equivalencia quantity fixed to 1');
              
              // Dispatch cart update event
              publish(PUB_SUB_EVENTS.cartUpdate, {
                source: 'checkout-hijacker-quantity-fix',
                cartData: data,
                variantId: variantId
              });
              
              // Update cart UI
              const cartItems = document.querySelector('cart-items');
              if (cartItems && typeof cartItems.onCartUpdate === 'function') {
                cartItems.onCartUpdate();
              }
              
              const cartDrawerItems = document.querySelector('cart-drawer-items');
              if (cartDrawerItems && typeof cartDrawerItems.onCartUpdate === 'function') {
                cartDrawerItems.onCartUpdate();
              }
              
              if (callback) callback();
            })
            .catch(error => {
              console.error('Error fixing recargo equivalencia quantity:', error);
              if (callback) callback();
            });
          } else {
            // Quantity is already 1 or product not in cart, continue
            if (callback) callback();
          }
        })
        .catch(error => {
          console.error('Error checking cart:', error);
          if (callback) callback();
        });
    }

    // Function to add product to cart
     addProductToCart(variantId, messageElement, onSuccess, onError) {
       const formData = {
         'items': [{
           'id': variantId,
           'quantity': 1
         }]
       };

       fetch('/cart/add.js', {
         method: 'POST',
         headers: {
           'Content-Type': 'application/json',
         },
         body: JSON.stringify(formData)
       })
       .then(response => {
         if (!response.ok) {
           throw new Error(`HTTP error! status: ${response.status}`);
         }
         return response.json();
       })
       .then(data => {
         console.log('Product added successfully:', data);
         
         // Check if the response indicates an error
         if (data.status && data.status === 422) {
           throw new Error(data.description || 'Error al aÃ±adir producto al carrito');
         }
         
         // Dispatch cart update event to refresh cart UI
         publish(PUB_SUB_EVENTS.cartUpdate, {
           source: 'checkout-hijacker',
           cartData: data,
           variantId: variantId
         });
         
         // Also directly call onCartUpdate for immediate refresh
         const cartItems = document.querySelector('cart-items');
         if (cartItems && typeof cartItems.onCartUpdate === 'function') {
           cartItems.onCartUpdate();
         }
         
         const cartDrawerItems = document.querySelector('cart-drawer-items');
         if (cartDrawerItems && typeof cartDrawerItems.onCartUpdate === 'function') {
           cartDrawerItems.onCartUpdate();
         }
         
         // Update the hidden input to reflect the new cart state
         const productCheckInput = document.getElementById('cart-product-check');
         if (productCheckInput) {
           productCheckInput.setAttribute('data-product-in-cart', 'true');
         }
         
         // Call success callback
         if (onSuccess) {
           onSuccess();
         }
       })
       .catch((error) => {
         console.error('Error adding product to cart:', error);
         
         // Call error callback
         if (onError) {
           onError();
         }
       });
     }

    // Function that handles the new button action
    newButtonAction(button) {
      if (!button) return;
      
      // Disable button permanently and show processing text
      button.disabled = true;
      button.setAttribute('disabled', 'true');
      button.setAttribute('aria-disabled', 'true');
      button.classList.add('disabled');
      button.style.opacity = '0.6';
      button.style.cursor = 'not-allowed';
      
      // Change button text to "Procesando..."
      const buttonText = button.querySelector('span') || button;
      buttonText.textContent = 'Procesando...';
      
      // Check the hidden input for re attribute
      const reInput = document.getElementById('cart-re-attribute');
      const hasReAttribute = reInput && reInput.hasAttribute('data-re') && reInput.getAttribute('data-re') === 'true';
      
      // Log for debugging
      console.log('Checkout button hijacked:', button);
      
      // Function to proceed to checkout
      const proceedToCheckout = () => {
        window.location.href = '/checkout';
      };
      
      // Check if customer has 're' tag
      if (hasReAttribute) {
        // Check if product is already in cart using the hidden input
        const productCheckInput = document.getElementById('cart-product-check');
        const productInCart = productCheckInput && productCheckInput.getAttribute('data-product-in-cart') === 'true';
        
        if (productInCart) {
          // Check and fix quantity before proceeding to checkout
          const variantId = this.getRecargoEquivalenciaVariant();
          if (variantId) {
            this.checkAndFixRecargoQuantity(variantId, proceedToCheckout);
          } else {
            proceedToCheckout();
          }
        } else {
          // Get product from theme settings
          const variantId = this.getRecargoEquivalenciaVariant();
          if (variantId) {
            // Create a dummy message element for the addProductToCart function
            const dummyMessageElement = document.createElement('div');
            this.addProductToCart(variantId, dummyMessageElement, () => {
              // After adding product, check and fix quantity before proceeding
              this.checkAndFixRecargoQuantity(variantId, proceedToCheckout);
            }, () => {
              // On error, just proceed to checkout anyway
              proceedToCheckout();
            });
          } else {
            // If product not configured, proceed to checkout anyway
            proceedToCheckout();
          }
        }
      } else {
        // For users without 're' tag, proceed directly to checkout
        proceedToCheckout();
      }
    }
  }

  // Initialize the hijacker
  new CheckoutHijacker();
</script>

<style>
  /* Optional: Style for disabled hijacked buttons */
  button.disabled {
    opacity: 0.6;
    cursor: not-allowed;
  }
</style>